[
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "a3a0c8ea-14cb-42f4-b6a9-740090473231",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC001-customer_management_api_functionality",
    "description": "Verify that the customer management API endpoints correctly handle creating, searching, updating, and retrieving customer information with valid data and proper validation.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nHEADERS = {\n    \"Content-Type\": \"application/json\"\n}\n\n\ndef test_customer_management_api_functionality():\n    # Customer data for creation\n    new_customer_data = {\n        \"first_name\": \"Jan\",\n        \"last_name\": \"de Vries\",\n        \"email\": \"jan.devries@example.com\",\n        \"phone_number\": \"0612345678\",\n        \"address\": {\n            \"street\": \"Dorpsstraat 1\",\n            \"city\": \"Amsterdam\",\n            \"postal_code\": \"1011AA\",\n            \"country\": \"NL\"\n        }\n    }\n\n    created_customer_id = None\n\n    try:\n        # 1. Create a new customer\n        create_resp = requests.post(\n            f\"{BASE_URL}/api/customers/\",\n            json=new_customer_data,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert create_resp.status_code == 201, f\"Expected 201 Created, got {create_resp.status_code}\"\n        created_customer = create_resp.json()\n        assert \"id\" in created_customer, \"Response missing customer ID\"\n        created_customer_id = created_customer[\"id\"]\n\n        # Validate returned fields match input for key fields\n        for field in [\"first_name\", \"last_name\", \"email\", \"phone_number\"]:\n            assert created_customer[field] == new_customer_data[field], f\"Mismatch in field {field}\"\n        for addr_field in [\"street\", \"city\", \"postal_code\", \"country\"]:\n            assert created_customer[\"address\"][addr_field] == new_customer_data[\"address\"][addr_field], f\"Address field {addr_field} mismatch\"\n\n        # 2. Search customer by phone number\n        search_resp = requests.get(\n            f\"{BASE_URL}/api/customers/search/\",\n            params={\"phone\": new_customer_data[\"phone_number\"]},\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert search_resp.status_code == 200, f\"Expected 200 OK for search, got {search_resp.status_code}\"\n        customers_found = search_resp.json()\n        assert isinstance(customers_found, list), \"Search response is not a list\"\n        assert any(c[\"id\"] == created_customer_id for c in customers_found), \"Created customer not found in search results\"\n\n        # 3. Update customer details\n        updated_data = {\n            \"first_name\": \"Jan Pieter\",\n            \"email\": \"jan.pieter.devries@example.com\",\n            \"address\": {\n                \"street\": \"Nieuwstraat 2\",\n                \"city\": \"Amsterdam\",\n                \"postal_code\": \"1011BB\",\n                \"country\": \"NL\"\n            }\n        }\n\n        update_resp = requests.put(\n            f\"{BASE_URL}/api/customers/{created_customer_id}/\",\n            json=updated_data,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert update_resp.status_code == 200, f\"Expected 200 OK on update, got {update_resp.status_code}\"\n        updated_customer = update_resp.json()\n\n        # Validate updated fields\n        assert updated_customer[\"first_name\"] == updated_data[\"first_name\"], \"First name not updated correctly\"\n        assert updated_customer[\"email\"] == updated_data[\"email\"], \"Email not updated correctly\"\n        for addr_field in [\"street\", \"city\", \"postal_code\", \"country\"]:\n            assert updated_customer[\"address\"][addr_field] == updated_data[\"address\"][addr_field], f\"Address field {addr_field} not updated\"\n\n        # 4. Retrieve customer information by ID\n        get_resp = requests.get(\n            f\"{BASE_URL}/api/customers/{created_customer_id}/\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert get_resp.status_code == 200, f\"Expected 200 OK on get, got {get_resp.status_code}\"\n        retrieved_customer = get_resp.json()\n\n        # Validate all data matches updated data\n        assert retrieved_customer[\"id\"] == created_customer_id, \"Customer ID mismatch on retrieval\"\n        assert retrieved_customer[\"first_name\"] == updated_data[\"first_name\"], \"First name mismatch on retrieval\"\n        assert retrieved_customer[\"email\"] == updated_data[\"email\"], \"Email mismatch on retrieval\"\n        for addr_field in [\"street\", \"city\", \"postal_code\", \"country\"]:\n            assert retrieved_customer[\"address\"][addr_field] == updated_data[\"address\"][addr_field], f\"Address field {addr_field} mismatch on retrieval\"\n\n    finally:\n        # Cleanup: delete the created customer if exists\n        if created_customer_id:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/api/customers/{created_customer_id}/\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT,\n                )\n                # Accept 200 OK or 204 No Content as successful deletion\n                assert del_resp.status_code in (200, 204), f\"Failed to delete customer, status {del_resp.status_code}\"\n            except Exception:\n                # Suppress exceptions on cleanup to not mask test results\n                pass\n\n\ntest_customer_management_api_functionality()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 117, in <module>\n  File \"<string>\", line 35, in test_customer_management_api_functionality\nAssertionError: Expected 201 Created, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.336Z",
    "modified": "2025-11-25T12:43:19.161Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "150dc3cc-93ed-4d66-9157-8d27680185da",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC002-order_management_api_status_workflow",
    "description": "Test the order management API endpoints for creating orders, updating order statuses through the full workflow (Nieuw, In behandeling, Klaar, Onderweg, Afgeleverd, Geannuleerd), and real-time tracking functionality.",
    "code": "import requests\nimport time\n\nBASE_URL = \"http://localhost:8000\"\nHEADERS = {\"Content-Type\": \"application/json\"}\nTIMEOUT = 30\n\ndef test_order_management_api_status_workflow():\n    # Status workflow sequence as per requirements\n    status_sequence = [\n        \"Nieuw\",           # New\n        \"In behandeling\",  # In progress\n        \"Klaar\",           # Ready\n        \"Onderweg\",        # On the way\n        \"Afgeleverd\",      # Delivered\n        \"Geannuleerd\"      # Cancelled\n    ]\n    \n    created_order_id = None\n\n    try:\n        # Step 1: Create a new order\n        new_order_payload = {\n            \"customer\": {\n                \"name\": \"Test Customer\",\n                \"phone\": \"0612345678\",\n                \"address\": \"Teststraat 1, Teststad\"\n            },\n            \"items\": [\n                {\n                    \"product_id\": 1,        # Assuming product_id 1 exists\n                    \"quantity\": 2,\n                    \"options\": []\n                }\n            ],\n            \"payment_method\": \"cash\",\n            \"notes\": \"Test order for status workflow\"\n        }\n        create_resp = requests.post(\n            f\"{BASE_URL}/orders\",\n            headers=HEADERS,\n            json=new_order_payload,\n            timeout=TIMEOUT\n        )\n        assert create_resp.status_code == 201, f\"Order creation failed: {create_resp.text}\"\n        created_order = create_resp.json()\n        created_order_id = created_order.get(\"id\")\n        assert created_order_id is not None, \"Created order ID missing\"\n        assert created_order.get(\"status\") == \"Nieuw\", f\"Initial order status not 'Nieuw', got {created_order.get('status')}\"\n\n        # Step 2: Update order status through the workflow except the last (Geannuleerd)\n        for status in status_sequence[1:-1]:\n            update_payload = {\"status\": status}\n            update_resp = requests.put(\n                f\"{BASE_URL}/orders/{created_order_id}/status\",\n                headers=HEADERS,\n                json=update_payload,\n                timeout=TIMEOUT\n            )\n            assert update_resp.status_code == 200, f\"Failed to update status to {status}: {update_resp.text}\"\n            updated_order = update_resp.json()\n            assert updated_order.get(\"status\") == status, f\"Order status not updated to {status}, got {updated_order.get('status')}\"\n\n            # Optionally verify current order via GET\n            get_resp = requests.get(\n                f\"{BASE_URL}/orders/{created_order_id}\",\n                headers=HEADERS,\n                timeout=TIMEOUT\n            )\n            assert get_resp.status_code == 200, f\"Failed to get order after status update to {status}\"\n            current_order = get_resp.json()\n            assert current_order.get(\"status\") == status, f\"GET order status mismatch: expected {status}, got {current_order.get('status')}\"\n\n        # Step 3: Test cancel status separately (Geannuleerd)\n        cancel_payload = {\"status\": \"Geannuleerd\"}\n        cancel_resp = requests.put(\n            f\"{BASE_URL}/orders/{created_order_id}/status\",\n            headers=HEADERS,\n            json=cancel_payload,\n            timeout=TIMEOUT\n        )\n        # Depending on business rules, cancelling might be allowed anytime or only if not delivered.\n        # Test expects it can be set.\n        assert cancel_resp.status_code == 200, f\"Failed to update status to Geannuleerd: {cancel_resp.text}\"\n        cancelled_order = cancel_resp.json()\n        assert cancelled_order.get(\"status\") == \"Geannuleerd\", f\"Order status not updated to Geannuleerd, got {cancelled_order.get('status')}\"\n\n        # Step 4: Test real-time tracking endpoint(s)\n        # Usually real-time tracking is via websocket, but try GET order tracking/status endpoint as fallback\n        tracking_resp = requests.get(\n            f\"{BASE_URL}/orders/{created_order_id}/tracking\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        # If endpoint exists, check response is 200 and contains statuses or tracking info\n        if tracking_resp.status_code == 200:\n            tracking_data = tracking_resp.json()\n            assert \"status\" in tracking_data, \"Tracking data missing 'status'\"\n            assert isinstance(tracking_data[\"status\"], str), \"Tracking status should be a string\"\n\n    finally:\n        # Cleanup: delete the created order\n        if created_order_id is not None:\n            try:\n                del_resp = requests.delete(\n                    f\"{BASE_URL}/orders/{created_order_id}\",\n                    headers=HEADERS,\n                    timeout=TIMEOUT\n                )\n                # Accept 200 or 204 as successful delete\n                assert del_resp.status_code in [200, 204], f\"Failed to delete order id {created_order_id}\"\n            except Exception:\n                pass  # Ignore delete failures in cleanup\n\ntest_order_management_api_status_workflow()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 115, in <module>\n  File \"<string>\", line 45, in test_order_management_api_status_workflow\nAssertionError: Order creation failed: {\"detail\":\"Not Found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.343Z",
    "modified": "2025-11-25T12:43:36.310Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "bc3e225c-84b4-4d0a-9871-78bd02400be4",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC003-menu_management_api_crud_operations",
    "description": "Validate the menu management API endpoints for adding, updating, deleting, and retrieving menu items, categories, and product options including availability and pricing updates.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef menu_management_api_crud_operations():\n    headers = {\"Content-Type\": \"application/json\"}\n    created_resources = {\"category_id\": None, \"menu_item_id\": None, \"product_option_id\": None}\n\n    # Helper function to delete created resources\n    def cleanup():\n        if created_resources[\"product_option_id\"]:\n            try:\n                resp = requests.delete(\n                    f\"{BASE_URL}/menu/product-options/{created_resources['product_option_id']}\",\n                    headers=headers,\n                    timeout=TIMEOUT,\n                )\n                assert resp.status_code == 204\n            except Exception:\n                pass\n        if created_resources[\"menu_item_id\"]:\n            try:\n                resp = requests.delete(\n                    f\"{BASE_URL}/menu/items/{created_resources['menu_item_id']}\",\n                    headers=headers,\n                    timeout=TIMEOUT,\n                )\n                assert resp.status_code == 204\n            except Exception:\n                pass\n        if created_resources[\"category_id\"]:\n            try:\n                resp = requests.delete(\n                    f\"{BASE_URL}/menu/categories/{created_resources['category_id']}\",\n                    headers=headers,\n                    timeout=TIMEOUT,\n                )\n                assert resp.status_code == 204\n            except Exception:\n                pass\n\n    try:\n        # 1. Create a category\n        category_payload = {\n            \"name\": f\"Test Category {uuid.uuid4()}\",\n            \"description\": \"Category for testing CRUD operations\"\n        }\n        response = requests.post(f\"{BASE_URL}/menu/categories\", json=category_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201\n        category = response.json()\n        assert \"id\" in category\n        assert category[\"name\"] == category_payload[\"name\"]\n        # Use get to avoid assertion error if description is missing in response\n        assert category.get(\"description\") == category_payload[\"description\"]\n        created_resources[\"category_id\"] = category[\"id\"]\n\n        # 2. Retrieve category - validate\n        response = requests.get(f\"{BASE_URL}/menu/categories/{category['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200\n        fetched_cat = response.json()\n        assert fetched_cat[\"id\"] == category[\"id\"]\n        assert fetched_cat[\"name\"] == category_payload[\"name\"]\n        assert fetched_cat.get(\"description\") == category_payload[\"description\"]\n\n        # 3. Update category\n        update_category_payload = {\"name\": f\"Updated Category {uuid.uuid4()}\", \"description\": \"Updated description\"}\n        response = requests.put(\n            f\"{BASE_URL}/menu/categories/{category['id']}\", json=update_category_payload, headers=headers, timeout=TIMEOUT\n        )\n        assert response.status_code == 200\n        updated_category = response.json()\n        assert updated_category.get(\"id\") == category[\"id\"]\n        assert updated_category[\"name\"] == update_category_payload[\"name\"]\n        assert updated_category.get(\"description\") == update_category_payload[\"description\"]\n\n        # 4. Create a menu item assigned to the category\n        menu_item_payload = {\n            \"name\": f\"Test Pizza {uuid.uuid4()}\",\n            \"description\": \"Delicious test pizza\",\n            \"category_id\": created_resources[\"category_id\"],\n            \"price\": 9.99,\n            \"available\": True\n        }\n        response = requests.post(f\"{BASE_URL}/menu/items\", json=menu_item_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201\n        menu_item = response.json()\n        assert \"id\" in menu_item\n        assert menu_item[\"name\"] == menu_item_payload[\"name\"]\n        created_resources[\"menu_item_id\"] = menu_item[\"id\"]\n\n        # 5. Retrieve menu item\n        response = requests.get(f\"{BASE_URL}/menu/items/{menu_item['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200\n        fetched_item = response.json()\n        assert fetched_item[\"id\"] == menu_item[\"id\"]\n        assert fetched_item[\"category_id\"] == created_resources[\"category_id\"]\n        assert fetched_item[\"available\"] is True\n        assert abs(fetched_item[\"price\"] - menu_item_payload[\"price\"]) < 0.001\n\n        # 6. Update menu item availability and price\n        update_item_payload = {\"available\": False, \"price\": 11.99, \"description\": \"Updated test pizza description\"}\n        response = requests.put(\n            f\"{BASE_URL}/menu/items/{menu_item['id']}\", json=update_item_payload, headers=headers, timeout=TIMEOUT\n        )\n        assert response.status_code == 200\n        updated_item = response.json()\n        assert updated_item[\"available\"] is False\n        assert abs(updated_item[\"price\"] - 11.99) < 0.001\n        assert updated_item[\"description\"] == update_item_payload[\"description\"]\n\n        # 7. Create a product option for the menu item\n        product_option_payload = {\n            \"menu_item_id\": menu_item[\"id\"],\n            \"name\": f\"Extra Cheese {uuid.uuid4()}\",\n            \"price\": 1.50,\n            \"available\": True\n        }\n        response = requests.post(f\"{BASE_URL}/menu/product-options\", json=product_option_payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201\n        product_option = response.json()\n        assert product_option[\"name\"] == product_option_payload[\"name\"]\n        created_resources[\"product_option_id\"] = product_option[\"id\"]\n\n        # 8. Retrieve product option\n        response = requests.get(f\"{BASE_URL}/menu/product-options/{product_option['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 200\n        fetched_option = response.json()\n        assert fetched_option[\"id\"] == product_option[\"id\"]\n        assert fetched_option[\"menu_item_id\"] == menu_item[\"id\"]\n        assert abs(fetched_option[\"price\"] - product_option_payload[\"price\"]) < 0.001\n\n        # 9. Update product option availability and price\n        update_option_payload = {\"available\": False, \"price\": 2.00, \"name\": \"Updated Extra Cheese\"}\n        response = requests.put(\n            f\"{BASE_URL}/menu/product-options/{product_option['id']}\", json=update_option_payload, headers=headers, timeout=TIMEOUT\n        )\n        assert response.status_code == 200\n        updated_option = response.json()\n        assert updated_option[\"available\"] is False\n        assert abs(updated_option[\"price\"] - 2.00) < 0.001\n        assert updated_option[\"name\"] == update_option_payload[\"name\"]\n\n        # 10. Delete product option\n        response = requests.delete(f\"{BASE_URL}/menu/product-options/{product_option['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 204\n        created_resources[\"product_option_id\"] = None\n\n        # 11. Delete menu item\n        response = requests.delete(f\"{BASE_URL}/menu/items/{menu_item['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 204\n        created_resources[\"menu_item_id\"] = None\n\n        # 12. Delete category\n        response = requests.delete(f\"{BASE_URL}/menu/categories/{category['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 204\n        created_resources[\"category_id\"] = None\n\n        # 13. Verify deletions: category\n        response = requests.get(f\"{BASE_URL}/menu/categories/{category['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 404\n        # 14. Verify deletions: menu item\n        response = requests.get(f\"{BASE_URL}/menu/items/{menu_item['id']}\", headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 404\n        # 15. Verify deletions: product option (already deleted)\n        # No need to verify again\n\n    finally:\n        cleanup()\n\nmenu_management_api_crud_operations()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 172, in <module>\n  File \"<string>\", line 51, in menu_management_api_crud_operations\nAssertionError\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.349Z",
    "modified": "2025-11-25T12:44:00.429Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "90efa32a-411a-42cb-9ead-b014f628a413",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC004-product_options_api_dynamic_pricing",
    "description": "Ensure the product options API correctly manages extras such as vlees, bijgerecht, sauzen, and garnering with dynamic price calculations and proper option associations.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_product_options_api_dynamic_pricing():\n    headers = {\n        \"Content-Type\": \"application/json\",\n    }\n\n    # Step 1: Create product options for each category: vlees, bijgerecht, sauzen, garnering\n    product_option_categories = [\"vlees\", \"bijgerecht\", \"sauzen\", \"garnering\"]\n    created_options = []\n\n    try:\n        for category in product_option_categories:\n            option_data = {\n                \"name\": f\"Test {category} option\",\n                \"category\": category,\n                \"price\": 1.50  # example dynamic price for testing\n            }\n            resp = requests.post(\n                f\"{BASE_URL}/api/extras\",\n                headers=headers,\n                timeout=TIMEOUT,\n                data=json.dumps(option_data)\n            )\n            assert resp.status_code == 201, f\"Failed to create {category} option: {resp.text}\"\n            created_option = resp.json()\n            assert created_option.get(\"id\") is not None, \"Created option missing 'id'\"\n            assert created_option.get(\"price\") == 1.50, \"Option price mismatch\"\n            assert created_option.get(\"category\") == category, \"Option category mismatch\"\n            created_options.append(created_option)\n\n        # Step 2: Retrieve the list of all product options and confirm our created options exist with correct prices and categories\n        resp = requests.get(\n            f\"{BASE_URL}/api/extras\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Failed to get product options: {resp.text}\"\n        all_options = resp.json()\n        option_ids = [o[\"id\"] for o in all_options]\n        for created_option in created_options:\n            assert created_option[\"id\"] in option_ids, f\"Option {created_option['id']} not found in list\"\n            # Verify correct association and price in detail\n            matching = next((o for o in all_options if o[\"id\"] == created_option[\"id\"]), None)\n            assert matching is not None, \"Option should be present\"\n            assert matching[\"category\"] == created_option[\"category\"], \"Category mismatch in list\"\n            assert matching[\"price\"] == created_option[\"price\"], \"Price mismatch in list\"\n\n        # Step 3: Test dynamic price update (simulate price change) for one option\n        update_data = {\n            \"price\": 2.25\n        }\n        option_to_update = created_options[0]\n        resp = requests.put(\n            f\"{BASE_URL}/api/extras/{option_to_update['id']}\",\n            headers=headers,\n            timeout=TIMEOUT,\n            data=json.dumps(update_data)\n        )\n        assert resp.status_code == 200, f\"Failed to update option price: {resp.text}\"\n        updated_option = resp.json()\n        assert updated_option[\"price\"] == 2.25, \"Price update did not apply\"\n\n        # Step 4: Verify dynamic pricing is reflected when retrieving this single option\n        resp = requests.get(\n            f\"{BASE_URL}/api/extras/{option_to_update['id']}\",\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert resp.status_code == 200, f\"Failed to get updated option: {resp.text}\"\n        fetched_option = resp.json()\n        assert fetched_option[\"price\"] == 2.25, \"Fetched option price mismatch after update\"\n        assert fetched_option[\"category\"] == option_to_update[\"category\"], \"Fetched category mismatch\"\n\n    finally:\n        # Cleanup: Delete all created options to maintain test isolation\n        for option in created_options:\n            try:\n                resp_del = requests.delete(\n                    f\"{BASE_URL}/api/extras/{option['id']}\",\n                    headers=headers,\n                    timeout=TIMEOUT\n                )\n                # Accept 200 or 204 as success for deletion\n                assert resp_del.status_code in (200, 204), f\"Failed to delete option {option['id']}: {resp_del.text}\"\n            except Exception:\n                pass  # ignore errors during cleanup to avoid masking test failures\n\ntest_product_options_api_dynamic_pricing()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 93, in <module>\n  File \"<string>\", line 29, in test_product_options_api_dynamic_pricing\nAssertionError: Failed to create vlees option: {\"detail\":\"Not Found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.354Z",
    "modified": "2025-11-25T12:43:14.936Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "d7bc3dad-614b-4fad-8148-558c3288aca9",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC005-shopping_cart_api_quantity_and_options",
    "description": "Test the shopping cart API for correct handling of quantity changes, product options display, and total price calculation.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\n\ndef create_menu_item():\n    payload = {\n        \"name\": \"Test Pizza\",\n        \"description\": \"Sample pizza for testing\",\n        \"price\": 8.00,\n        \"available\": True,\n        \"category\": \"Pizza\",\n        \"options\": [\n            {\n                \"name\": \"Size\",\n                \"choices\": [\n                    {\"name\": \"Small\", \"price\": 0},\n                    {\"name\": \"Medium\", \"price\": 2},\n                    {\"name\": \"Large\", \"price\": 4}\n                ]\n            },\n            {\n                \"name\": \"Extra Cheese\",\n                \"choices\": [\n                    {\"name\": \"Yes\", \"price\": 1},\n                    {\"name\": \"No\", \"price\": 0}\n                ]\n            }\n        ]\n    }\n    response = requests.post(\n        f\"{BASE_URL}/api/menu/items\",\n        json=payload,\n        headers=HEADERS,\n        timeout=TIMEOUT,\n    )\n    response.raise_for_status()\n    return response.json()  # Expecting a dict with item details including 'id'\n\n\ndef delete_menu_item(item_id):\n    response = requests.delete(\n        f\"{BASE_URL}/api/menu/items/{item_id}\",\n        headers=HEADERS,\n        timeout=TIMEOUT,\n    )\n    # Accept 204 No Content or 200 OK on deletion\n    if response.status_code not in (200, 204):\n        raise Exception(f\"Failed to delete menu item {item_id}, status code: {response.status_code}\")\n\n\ndef create_cart():\n    response = requests.post(\n        f\"{BASE_URL}/api/shopping_cart\",\n        json={},\n        headers=HEADERS,\n        timeout=TIMEOUT,\n    )\n    response.raise_for_status()\n    return response.json()  # Expecting a dict with cart info including 'id'\n\n\ndef delete_cart(cart_id):\n    response = requests.delete(\n        f\"{BASE_URL}/api/shopping_cart/{cart_id}\",\n        headers=HEADERS,\n        timeout=TIMEOUT,\n    )\n    if response.status_code not in (200, 204):\n        raise Exception(f\"Failed to delete shopping cart {cart_id}, status code: {response.status_code}\")\n\n\ndef test_shopping_cart_api_quantity_and_options():\n    # Create menu item to add to cart\n    menu_item = None\n    cart = None\n    try:\n        menu_item = create_menu_item()\n        menu_item_id = menu_item.get(\"id\")\n        assert menu_item_id, \"Menu item ID should be present after creation\"\n\n        # Create shopping cart\n        cart = create_cart()\n        cart_id = cart.get(\"id\")\n        assert cart_id, \"Cart ID should be present after creation\"\n\n        # Add product with options and quantity=1 to the cart\n        add_payload = {\n            \"product_id\": menu_item_id,\n            \"quantity\": 1,\n            \"options\": {\n                \"Size\": \"Medium\",\n                \"Extra Cheese\": \"Yes\"\n            }\n        }\n        add_response = requests.post(\n            f\"{BASE_URL}/api/shopping_cart/{cart_id}/items\",\n            json=add_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert add_response.status_code == 201, f\"Expected 201 Created, got {add_response.status_code}\"\n        item_data = add_response.json()\n        item_id = item_data.get(\"id\")\n        assert item_id, \"Cart item ID should be returned after adding item\"\n\n        # Get cart details to verify options and price calculation\n        get_cart_response = requests.get(\n            f\"{BASE_URL}/api/shopping_cart/{cart_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert get_cart_response.status_code == 200, f\"Expected 200 OK for get cart, got {get_cart_response.status_code}\"\n        cart_data = get_cart_response.json()\n\n        # Validate product options presence and correctness in the cart\n        items = cart_data.get(\"items\", [])\n        assert len(items) == 1, \"Cart should contain exactly one item\"\n        cart_item = items[0]\n        assert cart_item.get(\"product_id\") == menu_item_id, \"Product ID in cart item should match added product\"\n\n        options = cart_item.get(\"options\", {})\n        assert options.get(\"Size\") == \"Medium\", \"Product option 'Size' should be 'Medium'\"\n        assert options.get(\"Extra Cheese\") == \"Yes\", \"Product option 'Extra Cheese' should be 'Yes'\"\n\n        # Validate quantity is 1 initially\n        assert cart_item.get(\"quantity\") == 1, \"Initial quantity should be 1\"\n\n        # Validate total price calculation is correct\n        base_price = menu_item.get(\"price\", 0)\n        # Option prices from menu item definition\n        size_price = 2  # Medium size additional price\n        cheese_price = 1  # Extra cheese additional price\n        expected_price = (base_price + size_price + cheese_price) * 1\n        assert abs(cart_item.get(\"total_price\", 0) - expected_price) < 0.01, \"Total price calculation mismatch for quantity=1\"\n\n        # Change quantity to 3\n        update_payload = {\n            \"quantity\": 3\n        }\n        update_response = requests.put(\n            f\"{BASE_URL}/api/shopping_cart/{cart_id}/items/{item_id}\",\n            json=update_payload,\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert update_response.status_code == 200, f\"Expected 200 OK on quantity update, got {update_response.status_code}\"\n        updated_item = update_response.json()\n        assert updated_item.get(\"quantity\") == 3, \"Quantity should be updated to 3\"\n\n        # Get cart details again after quantity update\n        get_cart_response_2 = requests.get(\n            f\"{BASE_URL}/api/shopping_cart/{cart_id}\",\n            headers=HEADERS,\n            timeout=TIMEOUT,\n        )\n        assert get_cart_response_2.status_code == 200, \"Expected 200 OK for get cart after quantity update\"\n        cart_data_2 = get_cart_response_2.json()\n        items_2 = cart_data_2.get(\"items\", [])\n        assert len(items_2) == 1, \"Cart should still have one item after quantity update\"\n        cart_item_2 = items_2[0]\n\n        # Confirm total price reflects quantity 3\n        expected_price_quantity_3 = (base_price + size_price + cheese_price) * 3\n        assert abs(cart_item_2.get(\"total_price\", 0) - expected_price_quantity_3) < 0.01, \"Total price calculation mismatch for quantity=3\"\n\n        # Confirm options remain unchanged\n        options_2 = cart_item_2.get(\"options\", {})\n        assert options_2.get(\"Size\") == \"Medium\", \"Product option 'Size' should remain 'Medium' after quantity update\"\n        assert options_2.get(\"Extra Cheese\") == \"Yes\", \"Product option 'Extra Cheese' should remain 'Yes' after quantity update\"\n\n    finally:\n        # Cleanup created resources\n        if cart and \"id\" in cart:\n            try:\n                delete_cart(cart[\"id\"])\n            except Exception:\n                pass\n        if menu_item and \"id\" in menu_item:\n            try:\n                delete_menu_item(menu_item[\"id\"])\n            except Exception:\n                pass\n\n\ntest_shopping_cart_api_quantity_and_options()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 188, in <module>\n  File \"<string>\", line 80, in test_shopping_cart_api_quantity_and_options\n  File \"<string>\", line 39, in create_menu_item\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/api/menu/items\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.359Z",
    "modified": "2025-11-25T12:43:27.062Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "b21e3c83-56db-4183-b980-0cf62db95926",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC006-authentication_authorization_api_jwt_roles",
    "description": "Verify JWT-based authentication and role-based access control for Admin, Kassa, and Public users, ensuring secure login and restricted access to protected endpoints.",
    "code": "import requests\nfrom requests.exceptions import RequestException, Timeout\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_authentication_authorization_api_jwt_roles():\n    \"\"\"\n    Verify JWT-based authentication and role-based access control for Admin, Kassa,\n    and Public users, ensuring secure login and restricted access to protected endpoints.\n    \"\"\"\n    login_url = f\"{BASE_URL}/api/auth/login\"\n    protected_url = f\"{BASE_URL}/api/admin/dashboard\"  # Example protected endpoint for Admin\n    kassa_protected_url = f\"{BASE_URL}/api/kassa/orders\"  # Example protected endpoint for Kassa\n    public_protected_url = f\"{BASE_URL}/api/menu/public\"  # Example protected endpoint public users can access\n\n    # Credentials for different roles (these should exist in the system)\n    users = {\n        \"admin\": {\"username\": \"admin_user\", \"password\": \"admin_pass\"},\n        \"kassa\": {\"username\": \"kassa_user\", \"password\": \"kassa_pass\"},\n        \"public\": {\"username\": \"public_user\", \"password\": \"public_pass\"},\n        \"invalid\": {\"username\": \"invalid_user\", \"password\": \"wrong_pass\"},\n    }\n\n    tokens = {}\n\n    # Helper function to login and get JWT token\n    def login(user):\n        try:\n            resp = requests.post(\n                login_url,\n                json={\"username\": user[\"username\"], \"password\": user[\"password\"]},\n                headers={\"Content-Type\": \"application/json\"},\n                timeout=TIMEOUT,\n            )\n            return resp\n        except (RequestException, Timeout) as e:\n            assert False, f\"Login request failed: {e}\"\n\n    # 1. Test login success for Admin, Kassa, and Public users\n    for role in [\"admin\", \"kassa\", \"public\"]:\n        response = login(users[role])\n        assert response.status_code == 200, f\"{role} login failed with status {response.status_code}\"\n        json_data = response.json()\n        assert \"access_token\" in json_data, f\"{role} login response missing access_token\"\n        tokens[role] = json_data[\"access_token\"]\n        # Optionally verify token format (JWT tokens contain '.')\n        assert '.' in tokens[role], f\"{role} token is not a valid JWT\"\n\n    # 2. Test login failure for invalid credentials\n    invalid_response = login(users[\"invalid\"])\n    assert invalid_response.status_code == 401 or invalid_response.status_code == 400, \\\n        \"Invalid login should return 401 Unauthorized or 400 Bad Request\"\n\n    # 3. Test access to admin protected endpoint\n    # Admin user should have access\n    resp_admin = requests.get(\n        protected_url,\n        headers={\"Authorization\": f\"Bearer {tokens['admin']}\"},\n        timeout=TIMEOUT,\n    )\n    assert resp_admin.status_code == 200, \"Admin should access admin endpoint\"\n\n    # Kassa user should NOT have access to admin endpoint\n    resp_kassa_admin = requests.get(\n        protected_url,\n        headers={\"Authorization\": f\"Bearer {tokens['kassa']}\"},\n        timeout=TIMEOUT,\n    )\n    assert resp_kassa_admin.status_code in [401, 403], \"Kassa should NOT access admin endpoint\"\n\n    # Public user should NOT have access to admin endpoint\n    resp_public_admin = requests.get(\n        protected_url,\n        headers={\"Authorization\": f\"Bearer {tokens['public']}\"},\n        timeout=TIMEOUT,\n    )\n    assert resp_public_admin.status_code in [401, 403], \"Public user should NOT access admin endpoint\"\n\n    # 4. Test access to Kassa protected endpoint\n    # Kassa user should have access\n    resp_kassa = requests.get(\n        kassa_protected_url,\n        headers={\"Authorization\": f\"Bearer {tokens['kassa']}\"},\n        timeout=TIMEOUT,\n    )\n    assert resp_kassa.status_code == 200, \"Kassa user should access kassa endpoint\"\n\n    # Admin user should have access to Kassa endpoint (assuming admin has all rights)\n    resp_admin_kassa = requests.get(\n        kassa_protected_url,\n        headers={\"Authorization\": f\"Bearer {tokens['admin']}\"},\n        timeout=TIMEOUT,\n    )\n    assert resp_admin_kassa.status_code == 200, \"Admin should access kassa endpoint\"\n\n    # Public user should NOT have access to kassa endpoint\n    resp_public_kassa = requests.get(\n        kassa_protected_url,\n        headers={\"Authorization\": f\"Bearer {tokens['public']}\"},\n        timeout=TIMEOUT,\n    )\n    assert resp_public_kassa.status_code in [401, 403], \"Public user should NOT access kassa endpoint\"\n\n    # 5. Test access to Public endpoint (assuming public endpoint is accessible without token or with public token)\n    # Without token\n    resp_public_no_auth = requests.get(public_protected_url, timeout=TIMEOUT)\n    assert resp_public_no_auth.status_code in [200, 401], \"Public endpoint should be accessible or require auth\"\n\n    # With public token\n    resp_public_auth = requests.get(\n        public_protected_url,\n        headers={\"Authorization\": f\"Bearer {tokens['public']}\"},\n        timeout=TIMEOUT,\n    )\n    assert resp_public_auth.status_code == 200, \"Public user should access public endpoint\"\n\n    # 6. Access protected endpoints without token - should fail\n    resp_no_token_admin = requests.get(protected_url, timeout=TIMEOUT)\n    assert resp_no_token_admin.status_code == 401, \"Access without token to admin endpoint should be denied\"\n\n    resp_no_token_kassa = requests.get(kassa_protected_url, timeout=TIMEOUT)\n    assert resp_no_token_kassa.status_code == 401, \"Access without token to kassa endpoint should be denied\"\n\ntest_authentication_authorization_api_jwt_roles()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 125, in <module>\n  File \"<string>\", line 43, in test_authentication_authorization_api_jwt_roles\nAssertionError: admin login failed with status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.365Z",
    "modified": "2025-11-25T12:42:57.679Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "61a97a60-2cff-416f-8274-42f56be570a7",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC007-delivery_management_api_order_assignment",
    "description": "Test delivery management API endpoints for assigning orders to couriers, updating delivery status, and retrieving courier performance data.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\nHEADERS = {\"Content-Type\": \"application/json\"}\n\ndef test_delivery_management_api_order_assignment():\n    # Helper functions\n    def create_customer():\n        customer_data = {\n            \"name\": \"Test Customer\",\n            \"phone\": \"+310612345678\",\n            \"email\": \"testcustomer@example.com\",\n            \"address\": \"Teststraat 1, 1234AB Amsterdam\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/customers\", json=customer_data, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def create_menu_item():\n        menu_data = {\n            \"name\": \"Test Pizza\",\n            \"description\": \"Delicious test pizza\",\n            \"price\": 9.99,\n            \"category\": \"Pizza\",\n            \"available\": True\n        }\n        resp = requests.post(f\"{BASE_URL}/api/menu/items\", json=menu_data, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def create_order(customer_id, menu_item_id):\n        order_data = {\n            \"customer_id\": customer_id,\n            \"items\": [\n                {\n                    \"menu_item_id\": menu_item_id,\n                    \"quantity\": 1,\n                    \"options\": []\n                }\n            ]\n        }\n        resp = requests.post(f\"{BASE_URL}/api/orders\", json=order_data, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def create_courier():\n        courier_data = {\n            \"name\": \"Test Courier\",\n            \"phone\": \"+310698765432\"\n        }\n        resp = requests.post(f\"{BASE_URL}/api/couriers\", json=courier_data, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp.json()[\"id\"]\n\n    def assign_order_to_courier(order_id, courier_id):\n        assign_data = {\"courier_id\": courier_id}\n        resp = requests.put(f\"{BASE_URL}/api/deliveries/{order_id}/assign\", json=assign_data, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp\n\n    def update_delivery_status(order_id, status):\n        status_data = {\"status\": status}\n        resp = requests.put(f\"{BASE_URL}/api/deliveries/{order_id}/status\", json=status_data, headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp\n\n    def get_courier_performance(courier_id):\n        resp = requests.get(f\"{BASE_URL}/api/couriers/{courier_id}/performance\", headers=HEADERS, timeout=TIMEOUT)\n        resp.raise_for_status()\n        return resp\n\n    # Test execution with resource cleanup\n    customer_id = None\n    menu_item_id = None\n    order_id = None\n    courier_id = None\n\n    try:\n        # Setup resources\n        customer_id = create_customer()\n        menu_item_id = create_menu_item()\n        order_id = create_order(customer_id, menu_item_id)\n        courier_id = create_courier()\n\n        # Assign order to courier\n        resp_assign = assign_order_to_courier(order_id, courier_id)\n        assign_resp_json = resp_assign.json()\n        assert resp_assign.status_code == 200\n        assert \"assigned\" in assign_resp_json and assign_resp_json[\"assigned\"] is True\n\n        # Update delivery status stepwise and verify\n        for status in [\"In behandeling\", \"Onderweg\", \"Afgeleverd\"]:\n            resp_status = update_delivery_status(order_id, status)\n            status_resp_json = resp_status.json()\n            assert resp_status.status_code == 200\n            assert status_resp_json.get(\"status\") == status\n\n        # Retrieve courier performance data\n        resp_perf = get_courier_performance(courier_id)\n        perf_data = resp_perf.json()\n        assert resp_perf.status_code == 200\n        assert isinstance(perf_data, dict)\n        assert \"total_deliveries\" in perf_data\n        assert \"successful_deliveries\" in perf_data\n\n    finally:\n        # Cleanup orders, couriers, menu items, customers\n        if order_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/orders/{order_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if courier_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/couriers/{courier_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if menu_item_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/menu/items/{menu_item_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n        if customer_id:\n            try:\n                requests.delete(f\"{BASE_URL}/api/customers/{customer_id}\", headers=HEADERS, timeout=TIMEOUT)\n            except Exception:\n                pass\n\ntest_delivery_management_api_order_assignment()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 130, in <module>\n  File \"<string>\", line 81, in test_delivery_management_api_order_assignment\n  File \"<string>\", line 17, in create_customer\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/api/customers\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.370Z",
    "modified": "2025-11-25T12:43:19.813Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "58cdd674-6cf5-46af-9d86-d0113128d5b5",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC008-reporting_analytics_api_data_accuracy",
    "description": "Validate the reporting and analytics API endpoints for generating daily, monthly, and Z-reports with accurate product statistics, hourly breakdowns, and revenue tracking.",
    "code": "import requests\nfrom datetime import datetime, timedelta\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Assuming JWT authentication token needed; set your token here if applicable\nTOKEN = None  # e.g. \"eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...\"\nHEADERS = {\n    \"Content-Type\": \"application/json\",\n}\nif TOKEN:\n    HEADERS[\"Authorization\"] = f\"Bearer {TOKEN}\"\n\n\ndef test_reporting_analytics_api_data_accuracy():\n    try:\n        # Test generation of Daily Report with accurate product statistics, hourly breakdowns, and revenue tracking\n        daily_report_resp = requests.get(\n            f\"{BASE_URL}/api/reports/daily\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert daily_report_resp.status_code == 200, f\"Daily report failed: {daily_report_resp.text}\"\n        daily_data = daily_report_resp.json()\n\n        # Basic sanity checks on daily report content structure\n        assert \"date\" in daily_data, \"Daily report missing 'date' field\"\n        assert \"product_statistics\" in daily_data, \"Daily report missing 'product_statistics'\"\n        assert \"hourly_breakdown\" in daily_data, \"Daily report missing 'hourly_breakdown'\"\n        assert \"revenue\" in daily_data, \"Daily report missing 'revenue'\"\n\n        # Validate date is today or yesterday depending on implementation\n        daily_report_date = datetime.strptime(daily_data[\"date\"], \"%Y-%m-%d\")\n        assert daily_report_date.date() in {datetime.utcnow().date(), (datetime.utcnow() - timedelta(days=1)).date()}, \\\n            \"Daily report has unexpected date\"\n\n        # Validate product_statistics is a list and each element has expected keys\n        assert isinstance(daily_data[\"product_statistics\"], list), \"product_statistics should be a list\"\n        for product_stat in daily_data[\"product_statistics\"]:\n            assert \"product_id\" in product_stat, \"product_statistics item missing 'product_id'\"\n            assert \"quantity_sold\" in product_stat, \"product_statistics item missing 'quantity_sold'\"\n            assert isinstance(product_stat[\"quantity_sold\"], int), \"'quantity_sold' should be int\"\n            assert \"revenue\" in product_stat, \"product_statistics item missing 'revenue'\"\n            assert isinstance(product_stat[\"revenue\"], (int, float)), \"'revenue' should be a number\"\n\n        # Validate hourly_breakdown covers 24 hours and has expected keys\n        assert isinstance(daily_data[\"hourly_breakdown\"], list), \"hourly_breakdown should be a list\"\n        assert len(daily_data[\"hourly_breakdown\"]) == 24, \"hourly_breakdown should have 24 entries\"\n        for hour_data in daily_data[\"hourly_breakdown\"]:\n            assert \"hour\" in hour_data, \"hourly_breakdown entry missing 'hour'\"\n            assert 0 <= hour_data[\"hour\"] <= 23, \"'hour' should be between 0 and 23\"\n            assert \"orders_count\" in hour_data, \"hourly_breakdown entry missing 'orders_count'\"\n            assert isinstance(hour_data[\"orders_count\"], int), \"'orders_count' should be int\"\n            assert \"revenue\" in hour_data, \"hourly_breakdown entry missing 'revenue'\"\n            assert isinstance(hour_data[\"revenue\"], (int, float)), \"'revenue' should be a number\"\n\n        assert isinstance(daily_data[\"revenue\"], (int, float)), \"daily revenue should be a number\"\n        assert daily_data[\"revenue\"] >= 0, \"daily revenue should be non-negative\"\n\n        # Test generation of Monthly Report\n        monthly_report_resp = requests.get(\n            f\"{BASE_URL}/api/reports/monthly\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert monthly_report_resp.status_code == 200, f\"Monthly report failed: {monthly_report_resp.text}\"\n        monthly_data = monthly_report_resp.json()\n\n        assert \"month\" in monthly_data, \"Monthly report missing 'month' field\"\n        assert \"product_statistics\" in monthly_data, \"Monthly report missing 'product_statistics'\"\n        assert \"revenue\" in monthly_data, \"Monthly report missing 'revenue'\"\n\n        # Validate month format YYYY-MM\n        datetime.strptime(monthly_data[\"month\"], \"%Y-%m\")\n\n        # Validate product statistics structure as daily\n        assert isinstance(monthly_data[\"product_statistics\"], list), \"monthly product_statistics should be a list\"\n        for prod_stat in monthly_data[\"product_statistics\"]:\n            assert \"product_id\" in prod_stat\n            assert \"quantity_sold\" in prod_stat and isinstance(prod_stat[\"quantity_sold\"], int)\n            assert \"revenue\" in prod_stat and isinstance(prod_stat[\"revenue\"], (int, float))\n\n        assert isinstance(monthly_data[\"revenue\"], (int, float))\n        assert monthly_data[\"revenue\"] >= 0\n\n        # Test generation of Z-Report (end of day financial report)\n        z_report_resp = requests.get(\n            f\"{BASE_URL}/api/reports/z-report\",\n            headers=HEADERS,\n            timeout=TIMEOUT\n        )\n        assert z_report_resp.status_code == 200, f\"Z-report failed: {z_report_resp.text}\"\n        z_data = z_report_resp.json()\n\n        # Basic structure checks for z-report\n        assert \"date\" in z_data\n        assert \"total_sales\" in z_data\n        assert \"total_orders\" in z_data\n        assert \"product_stats\" in z_data\n        assert \"revenue_breakdown\" in z_data\n\n        # Validate types and values\n        z_report_date = datetime.strptime(z_data[\"date\"], \"%Y-%m-%d\")\n        assert z_report_date.date() in {datetime.utcnow().date(), (datetime.utcnow() - timedelta(days=1)).date()}\n\n        assert isinstance(z_data[\"total_sales\"], (int, float)) and z_data[\"total_sales\"] >= 0\n        assert isinstance(z_data[\"total_orders\"], int) and z_data[\"total_orders\"] >= 0\n        assert isinstance(z_data[\"product_stats\"], list)\n        for pstat in z_data[\"product_stats\"]:\n            assert \"product_id\" in pstat\n            assert \"quantity\" in pstat and isinstance(pstat[\"quantity\"], int)\n            assert \"revenue\" in pstat and isinstance(pstat[\"revenue\"], (int, float))\n\n        assert isinstance(z_data[\"revenue_breakdown\"], dict)\n        for key in [\"cash\", \"card\", \"voucher\", \"other\"]:\n            if key in z_data[\"revenue_breakdown\"]:\n                val = z_data[\"revenue_breakdown\"][key]\n                assert isinstance(val, (int, float)) and val >= 0\n\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\n    except Exception as ex:\n        assert False, f\"Assertion or parsing failed: {ex}\"\n\n\ntest_reporting_analytics_api_data_accuracy()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 24, in test_reporting_analytics_api_data_accuracy\nAssertionError: Daily report failed: {\"detail\":\"Not Found\"}\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 128, in <module>\n  File \"<string>\", line 125, in test_reporting_analytics_api_data_accuracy\nAssertionError: Assertion or parsing failed: Daily report failed: {\"detail\":\"Not Found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.375Z",
    "modified": "2025-11-25T12:43:17.954Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "b198a126-1eeb-4eb8-973b-7a9c8b005b07",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC009-receipt_generation_api_format_and_print",
    "description": "Ensure receipt generation API produces correctly formatted ESC/POS receipts with QR codes and integrates with thermal printers or print queue systems.",
    "code": "import requests\nimport json\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\n# Assuming authentication is required, provide valid credentials here\nAUTH_TOKEN = None  # Replace with actual token if available\n\ndef get_auth_headers():\n    headers = {\n        \"Content-Type\": \"application/json\",\n    }\n    if AUTH_TOKEN:\n        headers[\"Authorization\"] = f\"Bearer {AUTH_TOKEN}\"\n    return headers\n\ndef test_receipt_generation_api_format_and_print():\n    # Step 1: Create a sample order resource to generate receipt from\n    order_payload = {\n        \"customer\": {\n            \"name\": \"Test Customer\",\n            \"phone\": \"0612345678\",\n            \"email\": \"test@example.com\",\n            \"address\": \"Test Street 1, Amsterdam\"\n        },\n        \"items\": [\n            {\n                \"product_id\": 1,\n                \"quantity\": 2,\n                \"options\": [\n                    {\"option_id\": 11, \"price\": 0.5},\n                    {\"option_id\": 12, \"price\": 1.0}\n                ]\n            }\n        ],\n        \"payment_method\": \"cash\",\n        \"delivery\": False\n    }\n\n    order_id = None\n    try:\n        create_order_resp = requests.post(f\"{BASE_URL}/api/orders\", headers=get_auth_headers(), json=order_payload, timeout=TIMEOUT)\n        assert create_order_resp.status_code == 201, f\"Failed to create order: {create_order_resp.text}\"\n        order_data = create_order_resp.json()\n        order_id = order_data.get(\"id\")\n        assert order_id is not None, \"Order ID not returned on creation.\"\n\n        # Step 2: Request receipt generation for created order\n        receipt_resp = requests.post(f\"{BASE_URL}/api/receipt/generate\", headers=get_auth_headers(), json={\"order_id\": order_id}, timeout=TIMEOUT)\n        assert receipt_resp.status_code == 200, f\"Receipt generation failed: {receipt_resp.text}\"\n\n        receipt_data = receipt_resp.json()\n        # Validate receipt format keys\n        assert \"escpos_data\" in receipt_data or \"receipt_text\" in receipt_data, \"Receipt ESC/POS data or text not found in response.\"\n        escpos_data = receipt_data.get(\"escpos_data\")\n        if escpos_data:\n            # escpos_data should be a base64 or string representing ESC/POS command bytes, at least some data present\n            assert isinstance(escpos_data, str) and len(escpos_data) > 0, \"ESC/POS data is empty or invalid.\"\n\n        # Validate QR code presence in receipt\n        qr_code = receipt_data.get(\"qr_code\")\n        if qr_code:\n            # qr_code presumably base64 PNG or similar string representation\n            assert isinstance(qr_code, str) and len(qr_code) > 0, \"QR code data is empty or invalid.\"\n\n        # Optional: Validate print queue integration status if provided\n        print_status = receipt_data.get(\"print_status\")\n        if print_status:\n            assert print_status in [\"queued\", \"printed\", \"error\", \"not_configured\"], f\"Invalid print_status value: {print_status}\"\n\n    finally:\n        # Clean up: delete the created order if possible\n        if order_id:\n            try:\n                del_resp = requests.delete(f\"{BASE_URL}/api/orders/{order_id}\", headers=get_auth_headers(), timeout=TIMEOUT)\n                assert del_resp.status_code in (200, 204), f\"Failed to delete order {order_id}: {del_resp.text}\"\n            except Exception:\n                pass\n\ntest_receipt_generation_api_format_and_print()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 81, in <module>\n  File \"<string>\", line 44, in test_receipt_generation_api_format_and_print\nAssertionError: Failed to create order: {\"detail\":\"Not Found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.381Z",
    "modified": "2025-11-25T12:43:22.749Z"
  },
  {
    "projectId": "d9841675-0707-4180-9c9b-e8a264367575",
    "testId": "396fc5c7-eee1-46ee-aff3-bd66b2993fc5",
    "userId": "f418e468-00a1-7064-31b0-ad2dd6d44fb4",
    "title": "TC010-real_time_updates_api_websocket_stability",
    "description": "Test the WebSocket API for stable real-time order status updates, status change notifications, and synchronization with the admin dashboard.",
    "code": "import json\nimport threading\nimport time\nimport websocket\nimport requests\n\nBASE_URL = \"http://localhost:8000\"\nWS_URL = \"ws://localhost:8000/ws/orders\"\nREQUEST_TIMEOUT = 30\n\n# Credentials for authentication - adjust accordingly\nADMIN_CREDENTIALS = {\n    \"username\": \"admin\",\n    \"password\": \"adminpass\"\n}\n\ndef get_jwt_token():\n    try:\n        response = requests.post(f\"{BASE_URL}/api/auth/login\", json=ADMIN_CREDENTIALS, timeout=REQUEST_TIMEOUT)\n        response.raise_for_status()\n        token = response.json().get(\"access_token\")\n        assert token is not None, \"JWT token not found in login response\"\n        return token\n    except Exception as e:\n        raise RuntimeError(f\"Failed to authenticate and get JWT token: {e}\")\n\ndef create_order(token):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    # Minimal valid order payload - adjust if needed for your API\n    order_payload = {\n        \"customer_phone\": \"0612345678\",\n        \"items\": [\n            {\n                \"product_id\": 1,\n                \"quantity\": 1,\n                \"options\": []\n            }\n        ],\n        \"payment_method\": \"cash\",\n        \"delivery\": False\n    }\n    try:\n        response = requests.post(f\"{BASE_URL}/api/orders\", json=order_payload, headers=headers, timeout=REQUEST_TIMEOUT)\n        response.raise_for_status()\n        order_data = response.json()\n        order_id = order_data.get(\"id\")\n        assert order_id is not None, \"Order ID not found in create order response\"\n        return order_id\n    except Exception as e:\n        raise RuntimeError(f\"Failed to create order: {e}\")\n\ndef delete_order(order_id, token):\n    headers = {\"Authorization\": f\"Bearer {token}\"}\n    try:\n        response = requests.delete(f\"{BASE_URL}/api/orders/{order_id}\", headers=headers, timeout=REQUEST_TIMEOUT)\n        response.raise_for_status()\n    except Exception as e:\n        # Log or ignore, as cleanup might fail without affecting test result\n        pass\n\ndef real_time_updates_api_websocket_stability():\n    token = get_jwt_token()\n    order_id = None\n\n    # Prepare authentication header for websocket connection (commonly sent as a query param or header)\n    # Assume the WS endpoint accepts token as query param ?token=...\n    ws_url_with_token = f\"{WS_URL}?token={token}\"\n\n    # Event flags and storage for websocket messages\n    messages_received = []\n    error_occurred = [False]\n    ws_opened = [False]\n\n    def on_message(ws, message):\n        try:\n            data = json.loads(message)\n            # We expect updates about orders, check for order_id and relevant fields\n            if \"order_id\" in data and data[\"order_id\"] == order_id:\n                messages_received.append(data)\n        except Exception:\n            pass  # ignore malformed messages\n\n    def on_error(ws, error):\n        error_occurred[0] = True\n\n    def on_close(ws, close_status_code, close_msg):\n        ws_opened[0] = False\n\n    def on_open(ws):\n        ws_opened[0] = True\n\n    try:\n        # Create order to receive websocket updates for\n        order_id = create_order(token)\n        headers = {\"Authorization\": f\"Bearer {token}\"}\n\n        # Start websocket client in thread\n        ws = websocket.WebSocketApp(ws_url_with_token,\n                                    on_open=on_open,\n                                    on_message=on_message,\n                                    on_error=on_error,\n                                    on_close=on_close)\n\n        ws_thread = threading.Thread(target=ws.run_forever, kwargs={\"ping_interval\": 10, \"ping_timeout\": 5})\n        ws_thread.daemon = True\n        ws_thread.start()\n\n        # Wait for websocket to open or timeout\n        timeout_sec = 10\n        start_time = time.time()\n        while not ws_opened[0] and time.time() - start_time < timeout_sec:\n            time.sleep(0.1)\n        assert ws_opened[0], \"WebSocket connection failed to open.\"\n\n        # Update order status through workflow to trigger updates\n        statuses = [\"In behandeling\", \"Klaar\", \"Onderweg\", \"Afgeleverd\"]\n\n        for status in statuses:\n            update_payload = {\"status\": status}\n            resp = requests.put(f\"{BASE_URL}/api/orders/{order_id}/status\", json=update_payload, headers=headers, timeout=REQUEST_TIMEOUT)\n            resp.raise_for_status()\n            time.sleep(1)  # wait a bit for websocket to receive update\n\n        # Wait a bit more for any remaining messages\n        time.sleep(3)\n\n        # Validate websocket stability/no errors\n        assert not error_occurred[0], \"Error occurred in WebSocket connection.\"\n\n        # Validate at least one update per status received in websocket messages\n        received_statuses = set()\n        for msg in messages_received:\n            st = msg.get(\"status\")\n            if st:\n                received_statuses.add(st)\n        for expected_status in statuses:\n            assert expected_status in received_statuses, f\"Status '{expected_status}' update not received in real-time updates.\"\n\n    finally:\n        # Cleanup: close websocket and delete order\n        try:\n            ws.close()\n        except Exception:\n            pass\n        if order_id:\n            delete_order(order_id, token)\n\nreal_time_updates_api_websocket_stability()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 4, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2025-11-25T12:42:12.386Z",
    "modified": "2025-11-25T12:43:21.066Z"
  }
]
